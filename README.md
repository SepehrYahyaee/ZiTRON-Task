# ZiTRON-Task

## توضیح کلی Task
این تسک یک پیاده سازی ساده از یک سیستم رای دهنده است که در آن ادمین می تواند طرح بسازد. هر طرح که در دیتابیس و کد تحت عنوان Plan به آن ارجاع داده می شود یک متن داشته و یک deadline. کاربران می توانند طرح ها را مشاهده کرده و به آنها رای بدهند اما فقط تا زمانی می توانند به آنها رای بدهند که deadline طرح مورد نظر آنها نرسیده باشد.
فرض شده است که سیستم register در این سیستم وجود نداشته و از قبل یک سری کاربر با نام کاربری و پسورد مشخص حضور دارند.
در نهایت ۴ تا route در این سیستم برای این تسک نیاز است:
- کاربران Login کنند
- ادمین ها بتوانند طرح بسازند
- کاربران بتوانند به طرح ها رای بدهند در صورتی که لاگین کرده باشند
- ادمین ها بتوانند پس از سر رسیدن ددلاین طرح ها نتیجه آنها را مشاهده نمایند

در قسمت های زیر تمامی جوانب کد توضیح داده خواهد شد.

## دیتابیس و مدل Entity ها و ارتباط آنها
ترجیح برای انتخاب دیتابیس این تسک روی SQL یی ها بود بنابراین من PostgreSQL رو انتخاب کردم.
مدل دیتایی این تسک تا به اینجا و با این قابلیت های گفته شده به صورت زیر می باشد:
<figure>
<img src="./ERD.png" alt="ERD Model for this Task">
<figcaption> <strong>ERD</strong> for this simple Voting System.</figcaption>
</figure>

تمامی فیلد ها و ارتباطات آنها در دیاگرام بالا مشخص است. کاربران می توانند اگر ادمین باشند طرح را ساخته و کاربران نیز می توانند رای ساخته و آن را به یک طرج انتساب کنند اما فقط یک بار به هر طرح می توانند رای بدهند.

## ساختار فولدربندی و Structure کد
برای پیاده سازی بکند این تسک از Express.js استفاده شده است و از آنجایی که این فریم ورک یک فریم ورک Unopinionated است پس ساختاری که در این پروژه استفاده می شود کاملا به عهده برنامه نویس است. ساختاری که من استفاده کردم به شرح زیر است:

    ZiTRON-Task/
    ├── controllers/
    │   ├── index.js
    │   ├── plan.controllers.js
    │   ├── user.controllers.js
    ├── middlewares/
    │   ├── index.js
    │   ├── authentication.middleware.js
    │   ├── isAdmin.middleware.js
    │   └── validation.middleware.js
    ├── prisma/
    │   ├── migrations/
    │   ├── schema.prisma
    │   └── seeds.js
    ├── providers/
    │   ├── index.js
    │   ├── alreadyVoted.provider.js
    │   ├── createToken.provider.js
    │   └── loginChecker.provider.js
    ├── routes/
    │   ├── index.js
    │   ├── plan.routes.js
    │   └── user.routes.js
    ├── services/
    │   ├── index.js
    │   ├── plan.services.js
    │   ├── user.services.js
    │   └── vote.services.js
    ├── utilities/
    │   ├── index.js
    │   ├── asyncErrorHandler.util.js
    │   ├── customError.util.js
    │   ├── globalErrorHandler.util.js
    │   └── logger.util.js
    ├── app.js
    ├── db.js
    └── package.json

### Controllers
کنترلر ها **Endpoint** های ما هستند که وظیفه برگرداندن response و status code مناسب به کاربر را بر عهده دارند. تمامی فانکشن هایی که مربوط به مسیر های تعیین شده هستند و پاسخ نهایی را می دهند در این قسمت قرار دارند.

### Middlewares
فانکشن هایی برای بررسی و احراز هویت کاربران که قبل ازینکه request به دست کنترلر ها برسد اول از اینها می گذرد همگی در این قسمت قرار دارند از جمله **احراز هویت** کاربر و نیز ادمین بودن یا نبودن آن. همچنین بررسی درست بودن یا نبودن ورودی های مورد نیاز در هر API نیز در اینجا نوشته شده است که بعدا در Routes مورد استفاده قرار گرفته اند.

### Prisma
فولدر پریسما مربوط به تنظیمات **migration** و مدل های دیتابیس ماست. همچنین دارای یک فایل **seeds** است که وظیفه وارد کردن دیتا به دیتابیس برای تست را دارد چرا که قابلیت register در حال حاضر پیاده سازی نشده است.

### Providers
درون کنترلر ها هر موقع که به انجام کاری که مستقیما به فرستادن پاسخ به کاربر مربوط نیست نیاز باشد, توابع آن در این قسمت نوشته شده که اما درون خود کنترلر استفاده خواهد شد. برای تمیز بودن کد استفاده شده است و همچنین قابلیت ماژولاریتی.

### Routes
نقطه تلاقی کنترلر ها با میدلور ها در این فولدر است. در واقع در اینجا مسیر هایی مشخص را برای کنترلر های خود تعریف کرده و به ترتیب از هر میدلور و یا Endpoint یی که نیاز است استفاده بشود در آنها استفاده میکنیم.

### Services
در هر جا که نیاز باشد مستقیما با **دیتابیس** ارتباط برقرار کنیم از توابع این قسمت استفاده خواهیم کرد و مستقیما خودمان در فولدر های مختلف توابع برقراری ارتباط را نمینویسیم.

### Utilities
این فولدر برای نیازمندی های پروژه است که در کنار Validation که در قسمت میدلور ها استفاده شده بود باید در پروژه حضور داشته باشند. عمده فایل های آن مربوط به **Error Handling** می باشد که به قسمت های مختلف تقسیم شده است. ساختار کلی آن به این صورت است که یک کلاس کاستوم شده برای ارور ها تعریف شده و نیز یک ارور هندلر گلوبال که با app.use به خود اپلیکیشن متصل شده است. هر وقت که اروری در هر جایی از برنامه رخ بدهد به این تابع گلوبال انتقال داده خواهد شد و با توجه به نوع ارور آن هندل خواهد شد. همچنین یک asyncErrorHandler هم پیاده سازی شده است که نیازی به try/catch های پی در پی نباشد و در فولدر routes روی کنترلر ها اعمال شده است. در حقیقت یک wrapper یی اطراف کنترلر ها هست که روی آنها به صورت خودکار try/catch اعمال می کند.

### App.js and db.js
فایل app که محل اصلی اپلیکیشن ماست و محل اجرای سرور می باشد. فایل db نیز کانکشن متصل شونده به دیتابیس را به سرویس ها می فرستد که نیز بقیه فولدر ها برای ارتباط با دیتابیس از سرویس ها استفاده خواهند کرد.

در هر فولدر نیز یک index.js وجود دارد که محل تجمیع توابع یا مقادیر قابل export در آن فولدر هستند برای اینکه در هنگام import کردن هر چیزی صرفا به این فابل رجوع کنیم.

## نحوه راه اندازی
برای راه اندازی پروژه ابتدا دیتابیس PostgreSQL خودتون رو روی سیستم ران کرده و سپس می توانید این ریپازیتوری را clone کنید:

`git clone https://github.com/SepehrYahyaee/ZiTRON-Task.git`

سپس فایل `.env` خودتان را بسازید تا متغیر های محیطی مورد نیاز را ست کنید:

`DATABASE_URL = postgresql://username:password@localhost:5432/dbName`
`PORT = 3000 or your desired port`
`SECRET_KEY = RandomSecretKey`
`TOKEN_EXPIRE_TIME = 1d`

پس از آنکه فایل .env خود را ساختید با استفاده از دستورات زیر به ترتیب پروژه را می توانید اجرا کنید:

1. `npm install`
2. `npm run db`
3. `npm run test`

برای لاگین کردن و تست مسیر ها می توانید از دیتای زیر استفاده کنید:

- userName: "Hasan" - password: "1234" - role: "ADMIN"
- userName: "Heshmat" - password: "1234" - role: "USER"
- userName: "Gholam" - password: "1234" - role: "USER"

ازونجایی که مکانیزم رجیستر کردن هنوز پیاده سازی نشده به تبعیت از اون و صرفا برای تست این دیتا ها پیاده سازی شده و نیز مکانیزم Hashing برای وارد کردن پسورد ها درون دیتابیس پیاده سازی نشده است و صرفا چک کردن پسورد با String است!

نهایتا نیز **API Documentation** برای آن پیاده سازی شده است با استفاده از Swagger که بعد از ران کردن پروژه می توانید با استفاده از مسیر `localhost:PORT/api-docs` آن را مشاهده بفرمایید.